// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v4.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package io.flutter.plugins.google_maps_places_android

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

/** Generated class from Pigeon. */

enum class TypeFilterAndroid(val raw: Int) {
  ADDRESS(0),
  CITIES(1),
  ESTABLISHMENT(2),
  GEOCODE(3),
  REGIONS(4);

  companion object {
    fun ofRaw(raw: Int): TypeFilterAndroid? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class PlaceTypeAndroid(val raw: Int) {
  ACCOUNTING(0),
  ADMINISTRATIVEAREALEVEL1(1),
  ADMINISTRATIVEAREALEVEL2(2),
  ADMINISTRATIVEAREALEVEL3(3),
  ADMINISTRATIVEAREALEVEL4(4),
  ADMINISTRATIVEAREALEVEL5(5),
  AIRPORT(6),
  AMUSEMENTPARK(7),
  AQUARIUM(8),
  ARCHIPELAGO(9),
  ARTGALLERY(10),
  ATM(11),
  BAKERY(12),
  BANK(13),
  BAR(14),
  BEAUTYSALON(15),
  BICYCLESTORE(16),
  BOOKSTORE(17),
  BOWLINGALLEY(18),
  BUSSTATION(19),
  CAFE(20),
  CAMPGROUND(21),
  CARDEALER(22),
  CARRENTAL(23),
  CARREPAIR(24),
  CARWASH(25),
  CASINO(26),
  CEMETERY(27),
  CHURCH(28),
  CITYHALL(29),
  CLOTHINGSTORE(30),
  COLLOQUIALAREA(31),
  CONTINENT(32),
  CONVENIENCESTORE(33),
  COUNTRY(34),
  COURTHOUSE(35),
  DENTIST(36),
  DEPARTMENTSTORE(37),
  DOCTOR(38),
  DRUGSTORE(39),
  ELECTRICIAN(40),
  ELECTRONICSSTORE(41),
  EMBASSY(42),
  ESTABLISHMENT(43),
  FINANCE(44),
  FIRESTATION(45),
  FLOOR(46),
  FLORIST(47),
  FOOD(48),
  FUNERALHOME(49),
  FURNITURESTORE(50),
  GASSTATION(51),
  GENERALCONTRACTOR(52),
  GEOCODE(53),
  GROCERYORSUPERMARKET(54),
  GYM(55),
  HAIRCARE(56),
  HARDWARESTORE(57),
  HEALTH(58),
  HINDUTEMPLE(59),
  HOMEGOODSSTORE(60),
  HOSPITAL(61),
  INSURANCEAGENCY(62),
  INTERSECTION(63),
  JEWELRYSTORE(64),
  LAUNDRY(65),
  LAWYER(66),
  LIBRARY(67),
  LIGHTRAILSTATION(68),
  LIQUORSTORE(69),
  LOCALITY(70),
  LOCALGOVERNMENTOFFICE(71),
  LOCKSMITH(72),
  LODGING(73),
  MEALDELIVERY(74),
  MEALTAKEAWAY(75),
  MOSQUE(76),
  MOVIERENTAL(77),
  MOVIETHEATER(78),
  MOVINGCOMPANY(79),
  MUSEUM(80),
  NATURALFEATURE(81),
  NEIGHBORHOOD(82),
  NIGHTCLUB(83),
  OTHER(84),
  PAINTER(85),
  PARK(86),
  PARKING(87),
  PETSTORE(88),
  PHARMACY(89),
  PHYSIOTHERAPIST(90),
  PLACEOFWORSHIP(91),
  PLUMBER(92),
  PLUSCODE(93),
  POINTOFINTEREST(94),
  POLICE(95),
  POLITICAL(96),
  POSTALCODE(97),
  POSTALCODEPREFIX(98),
  POSTALCODESUFFIX(99),
  POSTALTOWN(100),
  POSTBOX(101),
  POSTOFFICE(102),
  PREMISE(103),
  PRIMARYSCHOOL(104),
  REALESTATEAGENCY(105),
  RESTAURANT(106),
  ROOFINGCONTRACTOR(107),
  ROOM(108),
  ROUTE(109),
  RVPARK(110),
  SCHOOL(111),
  SECONDARYSCHOOL(112),
  SHOESTORE(113),
  SHOPPINGMALL(114),
  SPA(115),
  STADIUM(116),
  STORAGE(117),
  STORE(118),
  STREETADDRESS(119),
  STREETNUMBER(120),
  SUBLOCALITY(121),
  SUBLOCALITYLEVEL1(122),
  SUBLOCALITYLEVEL2(123),
  SUBLOCALITYLEVEL3(124),
  SUBLOCALITYLEVEL4(125),
  SUBLOCALITYLEVEL5(126),
  SUBPREMISE(127),
  SUBWAYSTATION(128),
  SUPERMARKET(129),
  SYNAGOGUE(130),
  TAXISTAND(131),
  TOURISTATTRACTION(132),
  TOWNSQUARE(133),
  TRAINSTATION(134),
  TRANSITSTATION(135),
  TRAVELAGENCY(136),
  UNIVERSITY(137),
  VETERINARYCARE(138),
  ZOO(139);

  companion object {
    fun ofRaw(raw: Int): PlaceTypeAndroid? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LatLngAndroid (
  val latitude: Double? = null,
  val longitude: Double? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromMap(map: Map<String, Any?>): LatLngAndroid {
      val latitude = map["latitude"] as? Double
      val longitude = map["longitude"] as? Double

      return LatLngAndroid(latitude, longitude)
    }
  }
  fun toMap(): Map<String, Any?> {
    val map = mutableMapOf<String, Any?>()
    latitude?.let { map["latitude"] = it }
    longitude?.let { map["longitude"] = it }
    return map
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LatLngBoundsAndroid (
  val southwest: LatLngAndroid? = null,
  val northeast: LatLngAndroid? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromMap(map: Map<String, Any?>): LatLngBoundsAndroid {
      val southwest: LatLngAndroid? = (map["southwest"] as? Map<String, Any?>)?.let {
        LatLngAndroid.fromMap(it)
      }
      val northeast: LatLngAndroid? = (map["northeast"] as? Map<String, Any?>)?.let {
        LatLngAndroid.fromMap(it)
      }

      return LatLngBoundsAndroid(southwest, northeast)
    }
  }
  fun toMap(): Map<String, Any?> {
    val map = mutableMapOf<String, Any?>()
    southwest?.let { map["southwest"] = it.toMap() }
    northeast?.let { map["northeast"] = it.toMap() }
    return map
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class AutocompletePredictionAndroid (
  val distanceMeters: Long? = null,
  val fullText: String,
  val placeId: String,
  val placeTypes: List<Long?>,
  val primaryText: String,
  val secondaryText: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromMap(map: Map<String, Any?>): AutocompletePredictionAndroid {
      val distanceMeters = map["distanceMeters"].let { if (it is Int) it.toLong() else it as? Long }
      val fullText = map["fullText"] as String
      val placeId = map["placeId"] as String
      val placeTypes = map["placeTypes"] as List<Long?>
      val primaryText = map["primaryText"] as String
      val secondaryText = map["secondaryText"] as String

      return AutocompletePredictionAndroid(distanceMeters, fullText, placeId, placeTypes, primaryText, secondaryText)
    }
  }
  fun toMap(): Map<String, Any?> {
    val map = mutableMapOf<String, Any?>()
    distanceMeters?.let { map["distanceMeters"] = it }
    map["fullText"] = fullText
    map["placeId"] = placeId
    map["placeTypes"] = placeTypes
    map["primaryText"] = primaryText
    map["secondaryText"] = secondaryText
    return map
  }
}

@Suppress("UNCHECKED_CAST")
private object GoogleMapsPlacesApiAndroidCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          AutocompletePredictionAndroid.fromMap(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          LatLngAndroid.fromMap(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          LatLngBoundsAndroid.fromMap(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is AutocompletePredictionAndroid -> {
        stream.write(128)
        writeValue(stream, value.toMap())
      }
      is LatLngAndroid -> {
        stream.write(129)
        writeValue(stream, value.toMap())
      }
      is LatLngBoundsAndroid -> {
        stream.write(130)
        writeValue(stream, value.toMap())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GoogleMapsPlacesApiAndroid {
  fun findAutocompletePredictionsAndroid(query: String, locationBias: LatLngBoundsAndroid?, locationRestriction: LatLngBoundsAndroid?, origin: LatLngAndroid?, countries: List<String?>?, typeFilter: List<Long?>?, refreshToken: Boolean?, callback: (List<AutocompletePredictionAndroid?>) -> Unit)

  companion object {
    /** The codec used by GoogleMapsPlacesApiAndroid. */
    val codec: MessageCodec<Any?> by lazy {
      GoogleMapsPlacesApiAndroidCodec
    }
    /** Sets up an instance of `GoogleMapsPlacesApiAndroid` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: GoogleMapsPlacesApiAndroid?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.GoogleMapsPlacesApiAndroid.findAutocompletePredictionsAndroid", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val queryArg = args[0] as String
              val locationBiasArg = args[1] as? LatLngBoundsAndroid
              val locationRestrictionArg = args[2] as? LatLngBoundsAndroid
              val originArg = args[3] as? LatLngAndroid
              val countriesArg = args[4] as? List<String?>
              val typeFilterArg = args[5] as? List<Long?>
              val refreshTokenArg = args[6] as? Boolean
              api.findAutocompletePredictionsAndroid(queryArg, locationBiasArg, locationRestrictionArg, originArg, countriesArg, typeFilterArg, refreshTokenArg) {
                reply.reply(wrapResult(it))
              }
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
              reply.reply(wrapped)
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

private fun wrapResult(result: Any?): Map<String, Any?> {
  return hashMapOf("result" to result)
}

private fun wrapError(exception: Throwable): Map<String, Any> {
  return hashMapOf<String, Any>(
    "error" to hashMapOf<String, Any>(
      "code" to exception.javaClass.simpleName,
      "message" to exception.toString(),
      "details" to "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  )
}
