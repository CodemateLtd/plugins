// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v4.2.6), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif


/// Generated class from Pigeon.

enum TypeFilterIOS: Int {
  case address = 0
  case cities = 1
  case establishment = 2
  case geocode = 3
  case regions = 4
}

enum PlaceTypeIOS: Int {
  case accounting = 0
  case administrativeAreaLevel1 = 1
  case administrativeAreaLevel2 = 2
  case administrativeAreaLevel3 = 3
  case administrativeAreaLevel4 = 4
  case administrativeAreaLevel5 = 5
  case airport = 6
  case amusementPark = 7
  case aquarium = 8
  case archipelago = 9
  case artGallery = 10
  case atm = 11
  case bakery = 12
  case bank = 13
  case bar = 14
  case beautySalon = 15
  case bicycleStore = 16
  case bookStore = 17
  case bowlingAlley = 18
  case busStation = 19
  case cafe = 20
  case campground = 21
  case carDealer = 22
  case carRental = 23
  case carRepair = 24
  case carWash = 25
  case casino = 26
  case cemetery = 27
  case church = 28
  case cityHall = 29
  case clothingStore = 30
  case colloquialArea = 31
  case continent = 32
  case convenienceStore = 33
  case country = 34
  case courthouse = 35
  case dentist = 36
  case departmentStore = 37
  case doctor = 38
  case drugstore = 39
  case electrician = 40
  case electronicsStore = 41
  case embassy = 42
  case establishment = 43
  case finance = 44
  case fireStation = 45
  case floor = 46
  case florist = 47
  case food = 48
  case funeralHome = 49
  case furnitureStore = 50
  case gasStation = 51
  case generalContractor = 52
  case geocode = 53
  case groceryOrSupermarket = 54
  case gym = 55
  case hairCare = 56
  case hardwareStore = 57
  case health = 58
  case hinduTemple = 59
  case homeGoodsStore = 60
  case hospital = 61
  case insuranceAgency = 62
  case intersection = 63
  case jewelryStore = 64
  case laundry = 65
  case lawyer = 66
  case library = 67
  case lightRailStation = 68
  case liquorStore = 69
  case locality = 70
  case localGovernmentOffice = 71
  case locksmith = 72
  case lodging = 73
  case mealDelivery = 74
  case mealTakeaway = 75
  case mosque = 76
  case movieRental = 77
  case movieTheater = 78
  case movingCompany = 79
  case museum = 80
  case naturalFeature = 81
  case neighborhood = 82
  case nightClub = 83
  case other = 84
  case painter = 85
  case park = 86
  case parking = 87
  case petStore = 88
  case pharmacy = 89
  case physiotherapist = 90
  case placeOfWorship = 91
  case plumber = 92
  case plusCode = 93
  case pointOfInterest = 94
  case police = 95
  case political = 96
  case postalCode = 97
  case postalCodePrefix = 98
  case postalCodeSuffix = 99
  case postalTown = 100
  case postBox = 101
  case postOffice = 102
  case premise = 103
  case primarySchool = 104
  case realEstateAgency = 105
  case restaurant = 106
  case roofingContractor = 107
  case room = 108
  case route = 109
  case rvPark = 110
  case school = 111
  case secondarySchool = 112
  case shoeStore = 113
  case shoppingMall = 114
  case spa = 115
  case stadium = 116
  case storage = 117
  case store = 118
  case streetAddress = 119
  case streetNumber = 120
  case sublocality = 121
  case sublocalityLevel1 = 122
  case sublocalityLevel2 = 123
  case sublocalityLevel3 = 124
  case sublocalityLevel4 = 125
  case sublocalityLevel5 = 126
  case subpremise = 127
  case subwayStation = 128
  case supermarket = 129
  case synagogue = 130
  case taxiStand = 131
  case touristAttraction = 132
  case townSquare = 133
  case trainStation = 134
  case transitStation = 135
  case travelAgency = 136
  case university = 137
  case veterinaryCare = 138
  case zoo = 139
}

///Generated class from Pigeon that represents data sent in messages.
struct LatLngIOS {
  var latitude: Double? = nil
  var longitude: Double? = nil

  static func fromMap(_ map: [String: Any?]) -> LatLngIOS? {
    let latitude = map["latitude"] as? Double 
    let longitude = map["longitude"] as? Double 

    return LatLngIOS(
      latitude: latitude,
      longitude: longitude
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "latitude": latitude,
      "longitude": longitude
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct LatLngBoundsIOS {
  var southwest: LatLngIOS? = nil
  var northeast: LatLngIOS? = nil

  static func fromMap(_ map: [String: Any?]) -> LatLngBoundsIOS? {
    var southwest: LatLngIOS? = nil
    if let southwestMap = map["southwest"] as? [String: Any?] {
      southwest = LatLngIOS.fromMap(southwestMap)
    }
    var northeast: LatLngIOS? = nil
    if let northeastMap = map["northeast"] as? [String: Any?] {
      northeast = LatLngIOS.fromMap(northeastMap)
    }

    return LatLngBoundsIOS(
      southwest: southwest,
      northeast: northeast
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "southwest": southwest?.toMap(),
      "northeast": northeast?.toMap()
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct AutocompletePredictionIOS {
  var distanceMeters: Int32? = nil
  var fullText: String
  var placeId: String
  var placeTypes: [Int32?]
  var primaryText: String
  var secondaryText: String

  static func fromMap(_ map: [String: Any?]) -> AutocompletePredictionIOS? {
    let distanceMeters = map["distanceMeters"] as? Int32 
    let fullText = map["fullText"] as! String
    let placeId = map["placeId"] as! String
    let placeTypes = map["placeTypes"] as! [Int32?]
    let primaryText = map["primaryText"] as! String
    let secondaryText = map["secondaryText"] as! String

    return AutocompletePredictionIOS(
      distanceMeters: distanceMeters,
      fullText: fullText,
      placeId: placeId,
      placeTypes: placeTypes,
      primaryText: primaryText,
      secondaryText: secondaryText
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "distanceMeters": distanceMeters,
      "fullText": fullText,
      "placeId": placeId,
      "placeTypes": placeTypes,
      "primaryText": primaryText,
      "secondaryText": secondaryText
    ]
  }
}

private class GoogleMapsPlacesApiIOSCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return AutocompletePredictionIOS.fromMap(self.readValue() as! [String: Any])      
      case 129:
        return LatLngBoundsIOS.fromMap(self.readValue() as! [String: Any])      
      case 130:
        return LatLngIOS.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class GoogleMapsPlacesApiIOSCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AutocompletePredictionIOS {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else if let value = value as? LatLngBoundsIOS {
      super.writeByte(129)
      super.writeValue(value.toMap())
    } else if let value = value as? LatLngIOS {
      super.writeByte(130)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class GoogleMapsPlacesApiIOSCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return GoogleMapsPlacesApiIOSCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return GoogleMapsPlacesApiIOSCodecWriter(data: data)
  }
}

class GoogleMapsPlacesApiIOSCodec: FlutterStandardMessageCodec {
  static let shared = GoogleMapsPlacesApiIOSCodec(readerWriter: GoogleMapsPlacesApiIOSCodecReaderWriter())
}

///Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol GoogleMapsPlacesApiIOS {
  func findAutocompletePredictionsIOS(query: String, locationBias: LatLngBoundsIOS?, locationRestriction: LatLngBoundsIOS?, origin: LatLngIOS?, countries: [String?]?, typeFilter: [Int32?]?, refreshToken: Bool?, completion: @escaping ([AutocompletePredictionIOS?]?) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class GoogleMapsPlacesApiIOSSetup {
  /// The codec used by GoogleMapsPlacesApiIOS.
  static var codec: FlutterStandardMessageCodec { GoogleMapsPlacesApiIOSCodec.shared }
  /// Sets up an instance of `GoogleMapsPlacesApiIOS` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: GoogleMapsPlacesApiIOS?) {
    let findAutocompletePredictionsIOSChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.GoogleMapsPlacesApiIOS.findAutocompletePredictionsIOS", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      findAutocompletePredictionsIOSChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let queryArg = args[0] as! String
        let locationBiasArg = args[1] as? LatLngBoundsIOS
        let locationRestrictionArg = args[2] as? LatLngBoundsIOS
        let originArg = args[3] as? LatLngIOS
        let countriesArg = args[4] as? [String?]
        let typeFilterArg = args[5] as? [Int32?]
        let refreshTokenArg = args[6] as? Bool
        api.findAutocompletePredictionsIOS(query: queryArg, locationBias: locationBiasArg, locationRestriction: locationRestrictionArg, origin: originArg, countries: countriesArg, typeFilter: typeFilterArg, refreshToken: refreshTokenArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      findAutocompletePredictionsIOSChannel.setMessageHandler(nil)
    }
  }
}

private func wrapResult(_ result: Any?) -> [String: Any?] {
  return ["result": result]
}

private func wrapError(_ error: FlutterError) -> [String: Any?] {
  return [
    "error": [
      "code": error.code,
      "message": error.message,
      "details": error.details
    ]
  ]
}
